if cuvinte:

(
)
"(mai apare pentru ca dupa el urma o paranteza)

keywords:
module
func
export
param
result
nop
memory
call
call_indirect
drop
block
select
loop
br
br_if
br_table
return
table
funcref
elem
local
global
mut
type
unreachable
if
then
else
i32
i64
f32
f64

functii apelate:
"empty"
"singular"
"multi"
"nested"
"param"
"params"
"add64_u_with_carry"
"add64_u_saturated"
"as-select-first"
"as-select-mid"
"as-select-last"
"as-loop-first"
"as-loop-mid"
"as-loop-last"
"as-if-condition"
"as-br_if-first"
"as-br_if-last"
"as-br_table-first"
"as-br_table-last"
"as-call_indirect-first"
"as-call_indirect-mid"
"as-call_indirect-last"
"as-store-first"
"as-store-last"
"as-memory.grow-value"
"as-call-value"
"as-return-value"
"as-drop-operand"
"as-br-value"
"as-local.set-value"
"as-local.tee-value"
"as-global.set-value"
"as-load-operand"
"as-unary-operand"
"as-binary-operand"
"as-test-operand"
"as-compare-operand"
"as-binary-operands"
"as-compare-operands"
"as-mixed-operands"
"break-bare"
"break-value"
"break-multi-value"
"params-id"
"param-break"
"params-break"
"params-id-break"
"effects"
memory.grow
i32.store
i32.load
i32.add
i32.sub
i32.mul
i32.ctz
i32.eqz
i64.add
i64.extend_i32_u
i64.lt_u
f32.gt
local.get
local.set
local.tee
global.get
global.set

constante:
i32.const
i64.const
f32.const
f64.const

alias-uri:
	cuvinte/functii:
	$dummy
	$func
	$check
	$sig
	$l
	$f
	$a
	$i
	$j
	$c
	$k
	$x
	$l1(specific assert_malformed)
	$l2(specific assert_malformed)
	$add64_u_with_carry
	$add64_u_saturated
	$block-sig-1
	$block-sig-2
	$block-sig-3
	$block-sig-4

	functii cu alias specifice assert_invalid(nu le-am verificat pe toate, cand implementati dati voi va rog ctrl+f,dar am scos inainte restul cuvintelor si au ramas doar astea si banuiesc ca sunt de acolo pentru ca cele cam 10 pe care le am verificat erau):
	$type-empty-i32
	$type-empty-i64
	$type-empty-f32
	$type-empty-f64
	$type-then-value-num-vs-void
	$type-then-value-num-vs-void-else
	$type-else-value-num-vs-void
	$type-both-value-num-vs-void
	$type-then-value-nums-vs-void
	$type-then-value-nums-vs-void-else
	$type-else-value-nums-vs-void
	$type-both-value-nums-vs-void
	$type-then-value-empty-vs-num
	$type-else-value-empty-vs-num
	$type-both-value-empty-vs-num
	$type-then-value-empty-vs-nums
	$type-else-value-empty-vs-nums
	$type-both-value-empty-vs-nums
	$type-no-else-vs-num
	$type-no-else-vs-nums
	$type-then-value-void-vs-num
	$type-else-value-void-vs-num
	$type-both-value-void-vs-num
	$type-then-value-void-vs-nums
	$type-else-value-void-vs-nums
	$type-both-value-void-vs-nums
	$type-then-value-num-vs-num
	$type-else-value-num-vs-num
	$type-both-value-num-vs-num
	$type-then-value-num-vs-nums
	$type-else-value-num-vs-nums
	$type-both-value-num-vs-nums
	$type-then-value-partial-vs-nums
	$type-else-value-partial-vs-nums
	$type-both-value-partial-vs-nums
	$type-then-value-nums-vs-num
	$type-else-value-nums-vs-num
	$type-both-value-nums-vs-num
	$type-both-different-value-num-vs-num
	$type-both-different-value-nums-vs-nums
	$type-then-value-unreached-select
	$type-else-value-unreached-select
	$type-then-break-last-void-vs-num
	$type-else-break-last-void-vs-num
	$type-then-break-last-void-vs-nums
	$type-else-break-last-void-vs-nums
	$type-then-break-empty-vs-num
	$type-else-break-empty-vs-num
	$type-then-break-empty-vs-nums
	$type-else-break-empty-vs-nums
	$type-then-break-void-vs-num
	$type-else-break-void-vs-num
	$type-then-break-void-vs-nums
	$type-else-break-void-vs-nums
	$type-then-break-num-vs-num
	$type-else-break-num-vs-num
	$type-then-break-num-vs-nums
	$type-else-break-num-vs-nums
	$type-then-break-partial-vs-nums
	$type-else-break-partial-vs-nums
	$type-condition-empty
	$type-condition-empty-in-block
	$type-condition-empty-in-loop	
	$type-condition-empty-in-then
	$type-condition-empty-in-else
	$type-condition-empty-in-br
	$type-condition-empty-in-br_if
	$type-condition-empty-in-br_table
	$type-condition-empty-in-return
	$type-condition-empty-in-select
	$type-condition-empty-in-call
	$type-condition-empty-in-call_indirect
	$type-condition-empty-in-local.set
	$type-condition-empty-in-local.tee
	$type-condition-empty-in-global.set
	$type-condition-empty-in-memory.grow
	$type-condition-empty-in-load
	$type-condition-empty-in-store
	$type-param-void-vs-num
	$type-param-void-vs-nums
	$type-param-num-vs-num
	$type-param-num-vs-nums
	$type-param-nested-void-vs-num

numere intregi in baza 10: -3 -2 -1 0 1 7 8 9

assert-uri:
assert_return
assert_invalid
assert_trap 
assert_malformed

specific assert_return:
invoke
"type-use"


specific assert_invalid:
"type mismatch"

specific assert_trap:
invoke
"undefined element"

specific assert_malformed:
quote
end
"unexpected token"
"mismatching label"
"inline function type"
